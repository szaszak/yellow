mutate(#tempo_ajust_ciclo  = ciclo_comum / (speed_mps + 1.945864),
#tempo_najust_ciclo = ciclo_comum / (speed_mps + 0.139447),
dif_tempos_ciclo   = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
dif2 = (250 / (27.77778 + 0.139447)) - (250 / (27.77778 + 1.945864)))
res2019 %>%
# Remover linhas que não passaram por ciclovias
filter(ciclo_comum > 1000) %>%
mutate(index = row_number(),
speed_mps = speed / 3.6) %>%
select(index, speed_mps, distance, time, ciclo_comum) %>%
slice(2) %>%
mutate(#tempo_ajust_ciclo  = ciclo_comum / (speed_mps + 1.945864),
#tempo_najust_ciclo = ciclo_comum / (speed_mps + 0.139447),
dif_tempos_ciclo   = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
dif2 = (250 / (27.77778 + 0.14)) - (250 / (27.77778 + 1.9)))
res2019 %>%
# Remover linhas que não passaram por ciclovias
filter(ciclo_comum > 1000) %>%
mutate(index = row_number(),
speed_mps = speed / 3.6) %>%
select(index, speed_mps, distance, time, ciclo_comum) %>%
slice(2)
res2019 %>%
# Remover linhas que não passaram por ciclovias
filter(ciclo_comum > 1000) %>%
mutate(index = row_number(),
speed_mps = speed / 3.6) %>%
select(index, speed_mps, distance, time, ciclo_comum) %>%
slice(2) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)))
res2019 %>%
# Remover linhas que não passaram por ciclovias
filter(ciclo_comum > 1000) %>%
mutate(index = row_number(),
speed_mps = speed / 3.6) %>%
select(index, speed, speed_mps, distance, time, ciclo_comum) %>%
slice(2) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)))
# No exemplo a seguir, temos a velocidade média de 10,7 km/h (2,97 mps), distância
# total de 11.307 metros e distância em ciclovia de 1.050 metros. Isso resulta
# em uma compensação de 124 segundos ao tempo final.
res2019 %>%
# Remover linhas que não passaram por ciclovias
filter(ciclo_comum > 1000) %>%
mutate(index = row_number(),
speed_mps = speed / 3.6) %>%
select(index, speed, speed_mps, distance, time, ciclo_comum) %>%
slice(2) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + dif_tempo)
res2019 %>%
# Criar coluna temporária de velocidade em metros por segundo
mutate(speed_mps = speed / 3.6) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + dif_tempo)
res2019 %>%
# Criar coluna temporária de velocidade em metros por segundo
mutate(speed_mps = speed / 3.6) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + dif_tempo) %>%
select(index = row_number(),
index, speed, speed_mps, distance, time, ciclo_comum, dif_tempo, time_adj)
res2019 %>%
# Criar coluna temporária de velocidade em metros por segundo
mutate(speed_mps = speed / 3.6) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + dif_tempo,
index = row_number()) %>%
select(index, speed, speed_mps, distance, time, ciclo_comum, dif_tempo, time_adj)
res2019 %>%
# Criar coluna temporária de velocidade em metros por segundo
mutate(speed_mps = speed / 3.6) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + dif_tempo,
index = row_number()) %>%
select(index, speed, speed_mps, distance, time, ciclo_comum, dif_tempo, time_adj) %>%
sample_n(20)
0/10
res2019 %>%
# Criar coluna temporária de velocidade em metros por segundo
mutate(speed_mps = speed / 3.6) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + dif_tempo,
index = row_number()) %>%
select(index, speed, speed_mps, distance, time, ciclo_comum, dif_tempo, time_adj) %>%
sample_n(20)
(1 / 10.139447) - (1 / 11.806417)
res2019 %>%
# Criar coluna temporária de velocidade em metros por segundo
mutate(speed_mps = speed / 3.6) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + dif_tempo,
index = row_number()) %>%
select(index, speed, speed_mps, distance, time, ciclo_comum, dif_tempo, time_adj) %>%
sample_n(20)
res2019
res2019 %>%
# Criar coluna temporária de velocidade em metros por segundo
mutate(speed_mps = speed / 3.6) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + dif_tempo,
index = row_number(),
.before = 'via_comum')
res2019 %>%
# Criar coluna temporária de velocidade em metros por segundo
mutate(speed_mps = speed / 3.6) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(time_dif = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + time_dif,
index = row_number(),
.before = 'via_comum')
res2019 %>%
# Criar coluna temporária de velocidade em metros por segundo
mutate(speed_mps = speed / 3.6) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(time_dif = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + time_dif,
.before = 'via_comum') %>%
sample_n(20)
res2019 %>%
# Criar coluna temporária de velocidade em metros por segundo
mutate(speed_mps = speed / 3.6) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(time_dif = (ciclo_comum / (speed_mps + 0.139447)) - (ciclo_comum / (speed_mps + 1.945864)),
time_adj  = time + time_dif,
.before = 'via_comum') %>%
select(-speed_mps) %>%
sample_n(20)
res2019 %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(time_dif = (ciclo_comum / ((speed / 3.6) + 0.139447)) - (ciclo_comum / ((speed / 3.6) + 1.945864)),
time_adj  = time + time_dif,
.before = 'via_comum')
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
res2019 <-
res2019 %>%
mutate(time_dif = (ciclo_comum / ((speed / 3.6) + 0.139447)) - (ciclo_comum / ((speed / 3.6) + 1.945864)),
time_adj  = time + time_dif,
.before = 'via_comum')
res2028 <-
res2028 %>%
mutate(time_dif = (ciclo_comum / ((speed / 3.6) + 0.139447)) - (ciclo_comum / ((speed / 3.6) + 1.945864)),
time_adj  = time + time_dif,
.before = 'via_comum')
res2019 %>% filter(ciclo_comum > 0) %>%
res2019 %>%
filter(ciclo_comum > 0)
res2019 %>%
filter(ciclo_comum > 0)
res2019 %>%
filter(ciclo_comum > 0) %>%
select(distance, time, speed, time_dif, ciclo_comum)
res2019 %>%
filter(ciclo_comum > 0) %>%
mutate(speed_mps = speed / 3.6) %>%
select(speed_mps, time, distance, ciclo_comum, time_dif)
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
res2019 <-
res2019 %>%
mutate(time_dif = (ciclo_comum / ((speed / 3.6) + (0.139447 / 3.6))) - (ciclo_comum / ((speed / 3.6) + (1.945864 / 3.6))),
time_adj  = time + time_dif,
.before = 'via_comum')
# No exemplo a seguir, temos a velocidade média de 10,7 km/h (2,97 mps), distância
# total de 11.307 metros e distância em ciclovia de 1.050 metros. Isso resulta
# em uma compensação de 124 segundos ao tempo final.
res2019 %>%
# Remover linhas que não passaram por ciclovias
filter(ciclo_comum > 1000) %>%
mutate(index = row_number(),
speed_mps = speed / 3.6) %>%
select(index, speed, speed_mps, distance, time, ciclo_comum) %>%
slice(2) %>%
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
mutate(dif_tempo = (ciclo_comum / (speed_mps + (0.139447 / 3.6))) - (ciclo_comum / (speed_mps + (1.945864 / 3.6))),
time_adj  = time + dif_tempo)
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
res2019 <-
res2019 %>%
mutate(time_dif = (ciclo_comum / ((speed / 3.6) + (0.139447 / 3.6))) - (ciclo_comum / ((speed / 3.6) + (1.945864 / 3.6))),
time_adj  = time + time_dif,
.before = 'via_comum')
res2028 <-
res2028 %>%
mutate(time_dif = (ciclo_comum / ((speed / 3.6) + (0.139447 / 3.6))) - (ciclo_comum / ((speed / 3.6) + (1.945864 / 3.6))),
time_adj  = time + time_dif,
.before = 'via_comum')
res2019 %>%
filter(ciclo_comum > 0) %>%
mutate(speed_mps = speed / 3.6) %>%
select(speed_mps, time, distance, ciclo_comum, time_dif)
res2019 %>%
filter(ciclo_comum > 0) %>%
mutate(speed_mps = speed / 3.6) %>%
select(speed_mps, time, distance, ciclo_comum, time_dif) %>%
mutate(tempo_velciclovia_orig = ciclo_comum / (0.139447/3.6),
tempo_velciclovia_mais = ciclo_comum / (1.80586/3.6),
dif_entre_tempos = tempo_velciclovia_orig - tempo_velciclovia_mais,
dif_por_metro_percorrido = dif_entre_tempos / ciclo_comum)
res2019 %>%
filter(ciclo_comum > 0) %>%
mutate(speed_mps = speed / 3.6) %>%
select(speed_mps, time, distance, ciclo_comum, time_dif) %>%
mutate(tempo_velciclovia_orig = ciclo_comum / (0.139447/3.6),
tempo_velciclovia_mais = ciclo_comum / (1.945864/3.6),
dif_entre_tempos = tempo_velciclovia_orig - tempo_velciclovia_mais,
dif_por_metro_percorrido = dif_entre_tempos / ciclo_comum)
# dif_tempo = dist_em_ciclovia / (velocidade_média + 0.14) - dist_em_ciclovia / (velocidade_média + 1.95)
res2019 <-
res2019 %>%
mutate(time_dif = (ciclo_comum / ((speed / 3.6) + (0.139447 / 3.6))) - (ciclo_comum / ((speed / 3.6) + (1.945864 / 3.6))),
time_adj  = time + time_dif,
.before = 'via_comum')
res2028 <-
res2028 %>%
mutate(time_dif = (ciclo_comum / ((speed / 3.6) + (0.139447 / 3.6))) - (ciclo_comum / ((speed / 3.6) + (1.945864 / 3.6))),
time_adj  = time + time_dif,
.before = 'via_comum')
# Colunas a serem removidas ao abrir as bases de população e oportunidades
remove_cols <- c('year', 'abbrev_muni', 'name_muni', 'code_muni')
# IPEA - Shape de grid hexagonal (resolução 9)
hexagonos <- sprintf('%s/aop_hex_grid_v2.gpkg', dados_originais)
hexagonos <- read_sf(hexagonos) %>% filter(abbrev_muni == 'spo') %>% select(id_hex)
head(hexagonos)
# IPEA - População
# https://ipeagit.github.io/aopdata/reference/read_landuse.html
ipea_pop <- sprintf('%s/aop_population_2010_v2.csv', dados_originais)
ipea_pop <- read_delim(ipea_pop, delim = ',', col_types = "ccccciiiiiiiiiiiiiidii")
ipea_pop <- ipea_pop %>% filter(abbrev_muni == 'spo') %>% select(-all_of(remove_cols))
# Selecionar tipos de população
ipea_pop <-
ipea_pop %>%
select(id_hex,
# P001 - Total number of residents
# P002 - Number of white residents
# P003 - Number of black residents
# P004 - Number of indigenous residents
# P005 - Number of asian-descendents residents
# P006 - Number of men
# P007 - Number of women
matches('P00[1-7]')
)
head(ipea_pop)
# IPEA - Oportunidades
# https://ipeagit.github.io/aopdata/reference/read_landuse.html
ipea_oport <- sprintf('%s/aop_landuse_2019_v2.csv', dados_originais)
ipea_oport <- read_delim(ipea_oport, delim = ',', col_types = "ccccciiiiiiiiiiiiiiiii")
ipea_oport <- ipea_oport %>% filter(abbrev_muni == 'spo') %>% select(-all_of(remove_cols))
# Selecionar oportunidades totais
ipea_oport <-
ipea_oport %>%
select(id_hex,
# T001 - Total number of formal jobs
# E001 - Total number of public schools
# M001 - Total number of school enrollments
# S001 - Total number of healthcare facilities
# C001 - Total number of Social Assistance Reference Centers (CRAS)
T001,
E001,
M001,
S001,
C001
)
head(ipea_oport)
# Oportunidades acessadas a menos de 15 minutos (30 min = 1800 seg)
tempo_max <- 900
res2019 %>%
filter(time <= tempo_max)
res2019 %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex.y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex.x) %>%
summarise(CMATT15 = sum(T001, na.rm = TRUE),
CMAST15 = sum(S001, na.rm = TRUE),
CMAET15 = sum(E001, na.rm = TRUE),
CMAMT15 = sum(M001, na.rm = TRUE),
CMACT15 = sum(C001, na.rm = TRUE))
aop2019 <-
res2019 %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex.y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex.x) %>%
summarise(CMATT15 = sum(T001, na.rm = TRUE),
CMAST15 = sum(S001, na.rm = TRUE),
CMAET15 = sum(E001, na.rm = TRUE),
CMAMT15 = sum(M001, na.rm = TRUE),
CMACT15 = sum(C001, na.rm = TRUE))
rm(aop2019)
aop2019_15 <-
res2019 %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex.y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex.x) %>%
summarise(CMATT15 = sum(T001, na.rm = TRUE),
CMAST15 = sum(S001, na.rm = TRUE),
CMAET15 = sum(E001, na.rm = TRUE),
CMAMT15 = sum(M001, na.rm = TRUE),
CMACT15 = sum(C001, na.rm = TRUE))
# Calcular acesso a oportunidades - IPEA está acessando tempos de 900 a 1050 seg
aop2019_30 <-
ttmatrix %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex_y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex_x) %>%
summarise(CMATT30 = sum(T001, na.rm = TRUE),
CMAST30 = sum(S001, na.rm = TRUE),
CMAET30 = sum(E001, na.rm = TRUE),
CMAMT30 = sum(M001, na.rm = TRUE),
CMACT30 = sum(C001, na.rm = TRUE))
# Oportunidades acessadas a menos de 40 minutos (30 min = 1800 seg)
tempo_max <- 2400
# Calcular acesso a oportunidades - IPEA está acessando tempos de 900 a 1050 seg
aop2019_45 <-
ttmatrix %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex_y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex_x) %>%
summarise(CMATT40 = sum(T001, na.rm = TRUE),
CMAST40 = sum(S001, na.rm = TRUE),
CMAET40 = sum(E001, na.rm = TRUE),
CMAMT40 = sum(M001, na.rm = TRUE),
CMACT40 = sum(C001, na.rm = TRUE))
# Juntar todos os acessos a oportunidades por faixa de tempo
aop_2019 <-
aop2019_15 %>%
left_join(aop2019_30, by = 'id_hex_x') %>%
left_join(aop2019_45, by = 'id_hex_x') %>%
rename(id_hex = id_hex_x)
aop_2019
# Oportunidades acessadas a menos de 15 minutos (30 min = 1800 seg)
tempo_max <- 900
aop2019_15 <-
res2019 %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex.y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex.x) %>%
summarise(CMATT15 = sum(T001, na.rm = TRUE),
CMAST15 = sum(S001, na.rm = TRUE),
CMAET15 = sum(E001, na.rm = TRUE),
CMAMT15 = sum(M001, na.rm = TRUE),
CMACT15 = sum(C001, na.rm = TRUE))
# Oportunidades acessadas a menos de 30 minutos (30 min = 1800 seg)
tempo_max <- 1800
# Calcular acesso a oportunidades - IPEA está acessando tempos de 900 a 1050 seg
aop2019_30 <-
ttmatrix %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex_y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex_x) %>%
summarise(CMATT30 = sum(T001, na.rm = TRUE),
CMAST30 = sum(S001, na.rm = TRUE),
CMAET30 = sum(E001, na.rm = TRUE),
CMAMT30 = sum(M001, na.rm = TRUE),
CMACT30 = sum(C001, na.rm = TRUE))
# Calcular acesso a oportunidades - IPEA está acessando tempos de 900 a 1050 seg
aop2019_30 <-
res2019 %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex_y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex_x) %>%
summarise(CMATT30 = sum(T001, na.rm = TRUE),
CMAST30 = sum(S001, na.rm = TRUE),
CMAET30 = sum(E001, na.rm = TRUE),
CMAMT30 = sum(M001, na.rm = TRUE),
CMACT30 = sum(C001, na.rm = TRUE))
# Calcular acesso a oportunidades - IPEA está acessando tempos de 900 a 1050 seg
aop2019_30 <-
res2019 %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex.y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex_x) %>%
summarise(CMATT30 = sum(T001, na.rm = TRUE),
CMAST30 = sum(S001, na.rm = TRUE),
CMAET30 = sum(E001, na.rm = TRUE),
CMAMT30 = sum(M001, na.rm = TRUE),
CMACT30 = sum(C001, na.rm = TRUE))
# Calcular acesso a oportunidades - IPEA está acessando tempos de 900 a 1050 seg
aop2019_30 <-
res2019 %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex.y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex.x) %>%
summarise(CMATT30 = sum(T001, na.rm = TRUE),
CMAST30 = sum(S001, na.rm = TRUE),
CMAET30 = sum(E001, na.rm = TRUE),
CMAMT30 = sum(M001, na.rm = TRUE),
CMACT30 = sum(C001, na.rm = TRUE))
# Oportunidades acessadas a menos de 40 minutos (30 min = 1800 seg)
tempo_max <- 2400
# Calcular acesso a oportunidades - IPEA está acessando tempos de 900 a 1050 seg
aop2019_45 <-
res2019 %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex.y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex.x) %>%
summarise(CMATT40 = sum(T001, na.rm = TRUE),
CMAST40 = sum(S001, na.rm = TRUE),
CMAET40 = sum(E001, na.rm = TRUE),
CMAMT40 = sum(M001, na.rm = TRUE),
CMACT40 = sum(C001, na.rm = TRUE))
# Juntar todos os acessos a oportunidades por faixa de tempo
aop_2019 <-
aop2019_15 %>%
left_join(aop2019_30, by = 'id_hex_x') %>%
left_join(aop2019_45, by = 'id_hex_x') %>%
rename(id_hex = id_hex_x)
# Juntar todos os acessos a oportunidades por faixa de tempo
aop_2019 <-
aop2019_15 %>%
left_join(aop2019_30, by = 'id_hex.x') %>%
left_join(aop2019_45, by = 'id_hex.x') %>%
rename(id_hex = id_hex_x)
# Juntar todos os acessos a oportunidades por faixa de tempo
aop_2019 <-
aop2019_15 %>%
left_join(aop2019_30, by = 'id_hex.x') %>%
left_join(aop2019_45, by = 'id_hex.x') %>%
rename(id_hex = id_hex.x)
aop_2019
# Calcular acesso a oportunidades - IPEA está acessando tempos de 900 a 1050 seg
aop2019_45 <-
res2019 %>%
filter(time <= tempo_max) %>%
# Juntar oportunidades acessadas
left_join(ipea_oport, by = c('id_hex.y' = 'id_hex')) %>%
# Agrupar a partir do hexágono de origem e somar as oportunidades
group_by(id_hex.x) %>%
summarise(CMATT45 = sum(T001, na.rm = TRUE),
CMAST45 = sum(S001, na.rm = TRUE),
CMAET45 = sum(E001, na.rm = TRUE),
CMAMT45 = sum(M001, na.rm = TRUE),
CMACT45 = sum(C001, na.rm = TRUE))
# Juntar todos os acessos a oportunidades por faixa de tempo
aop_2019 <-
aop2019_15 %>%
left_join(aop2019_30, by = 'id_hex.x') %>%
left_join(aop2019_45, by = 'id_hex.x') %>%
rename(id_hex = id_hex.x)
aop_2019
hexagonos
# Juntar ao shape de hexágonos
hexagonos <- hexagonos %>% left_join(aop_2019, by = 'id_hex')
hexagonos
# Jogar coluna de geom para a última
hexagonos <- hexagonos %>% select(-geom, geom)
hexagonos
# Substituir NAs por zeros
hexagonos <- hexagonos %>% mutate(across(where(is.numeric), ~replace_na(.x, 0)))
head(hexagonos)
hexagonos %>% filter(CMATT15 > 0)
hexagonos %>% filter(CMATT15 > 0) %>% select(id_hex, matches('T15'))
this <- hexagonos %>% filter(CMATT15 > 0) %>% select(id_hex, matches('T15'))
mapview(this)
library('mapview')
mapview(this)
res2019
remotes::install_github("ciclocidade/radarsp")
library("radarsp")
remotes::install_github("ciclocidade/radarsp")
install.packages('arrow')
install.packages('arrow')
install.packages('arrow')
?install.packages
Sys.setenv("NOT_CRAN" = "true")
install.packages("arrow")
remotes::install_github("ciclocidade/radarsp")
remotes::install_github("ciclocidade/radarsp")
utils::remove.packages("radarsp")
remotes::install_github("ciclocidade/radarsp")
remotes::install_github("ciclocidade/radarsp")
remotes::install_github("ciclocidade/radarsp")
?install_github
utils::remove.packages("radarsp")
remotes::install_github("ciclocidade/radarsp")
remotes::install_github("ciclocidade/radarsp", ref = "dev")
remotes::install_github("ciclocidade/radarsp", ref = "dev")
remotes::install_github("ciclocidade/radarsp")
remotes::install_github("ciclocidade/radarsp")
remotes::install_github("ciclocidade/radarsp")
remotes::install_github("ciclocidade/radarsp@v.004")
remotes::install_github("ciclocidade/radarsp")
