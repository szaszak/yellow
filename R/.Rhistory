summary(ols_resultados)
# Teste de correlação entre as variáveis
cor.test(resultados$veloc, resultados$dist, method = "pearson")
ceiling(nrow(resultados)/10)
aa
?distinct
tching e realiza os cálculos referentes a rotas completas
# carregar bibliotecas
source('fun/setup.R')
source('fun/st_dbscan.R')
source('fun/funcoes_rotas.R')
source('fun/valhalla_map_matching.R')
detach("package:tidylog")
# Estrutura de pastas
pasta_dados        <- "../../yellow_dados"
pasta_viagens_sp   <- sprintf("%s/01_viagens_em_sp", pasta_dados)
pasta_osm_sp       <- sprintf("%s/02_osm_simplificado_sp", pasta_dados)
pasta_elevacao     <- sprintf("%s/03_curva_elevacao_sp", pasta_dados)
pasta_semaforos    <- sprintf("%s/04_semaforos_sp", pasta_dados)
# pasta_base   <- sprintf("%s/05_testes_20_viagens_clusters", pasta_dados)
# pasta_base         <- sprintf("%s/05_testes_200_viagens_clusters", pasta_dados)
pasta_base         <- sprintf("%s/05_testes_viagens_20181112-20181117", pasta_dados)
pasta_viagens_gpkg <- sprintf("%s/viagens_processadas_gpkg", pasta_base)
pasta_viagens_pngs <- sprintf("%s/viagens_processadas_pngs", pasta_base)
pasta_viagens_csv1 <- sprintf("%s/viagens_processadas_csv1", pasta_base)
pasta_viagens_csv2 <- sprintf("%s/viagens_processadas_csv2", pasta_base)
dir.create(pasta_viagens_gpkg, recursive = TRUE, showWarnings = FALSE)
dir.create(pasta_viagens_pngs, recursive = TRUE, showWarnings = FALSE)
dir.create(pasta_viagens_csv1, recursive = TRUE, showWarnings = FALSE)
dir.create(pasta_viagens_csv2, recursive = TRUE, showWarnings = FALSE)
# ----------------------------------------------------------
# Abrir dados de apoio para os cálculos nas rotas
# ----------------------------------------------------------
# Abrir listagem de vias com infraestrutura cicloviária
vias_ciclo <- sprintf('%s/listagem_vias_infra_cicloviaria.csv', pasta_osm_sp)
vias_ciclo <- read_delim(vias_ciclo, delim = ';', col_types = cols(.default = "c"))
vias_ciclo <- vias_ciclo %>% select(osm_id, osm_cycletype = tipo_2018)
# Abrir listagem de vias em áreas com alguma restrição - parques, principalmente
vias_restritas <- sprintf('%s/listagem_vias_em_areas_restritas.csv', pasta_osm_sp)
vias_restritas <- read_delim(vias_restritas, delim = ';', col_types = cols(.default = "c"))
# # Abrir shape com linhas mestra e intermediária de elevação do Geosampa
# pontos_elevacao <- sprintf('%s/geosampa_pontos_de_elevacao_no_viario.gpkg', pasta_elevacao)
# pontos_elevacao <- read_sf(pontos_elevacao)
# Abrir shape com viário do OpenStreetMap com valoz Z incluído, vindo do MDT de SP
pontos_elevacao <- sprintf('%s/viario_osm_com_elevacao_mdt_sem_z.gpkg', pasta_elevacao)
pontos_elevacao <- read_sf(pontos_elevacao)
# Renomear coluna de elevação para 'ISOVALOR'
pontos_elevacao <- pontos_elevacao %>% rename(ISOVALOR = elev_mdt)
# Abrir esquinas com semáforos - buffers de 25m a partir do shape da CET
semaforos <- sprintf('%s/semaforos_buffer25_sp_dissolved.gpkg', pasta_semaforos)
semaforos <- read_sf(semaforos)
# ----------------------------------------------------------
# Abrir base de viagens
# ----------------------------------------------------------
# # Abrir a base de viagens da Yellow em SP
# open_file <- sprintf('%s/sp_20_viagens_teste.rds', pasta_base)
# viagens <- read_rds(open_file) %>% select(-n_points)
# Abrir a base de viagens da Yellow em SP
open_file <- sprintf('%s/sp_viagens_yellow.rds', pasta_viagens_sp)
yellow_sp <- read_rds(open_file) %>% rename(lat = lats,
lon = longs)
# Definir tempo mínimo de viagem, em segundos.Considerando uma média de 1 ponto
# a cada 5 segundos, temos: 18 pontos - 90 segundos - cerca de 300 metros a 12km/h.
# Com isso, rotas curtas são:
# 1. Com tempo menor do que 30s;
# 2. Com distância menor do que 300m;
# 3. Com quantidade mínima de 18 pontos
tempo_min_viagem <- 90
dist_min_viagem  <- 300
qtd_min_pontos   <- 18
# van de Coevering et al. (2014) consideraram como paradas quando ciclistas
# ficam mais de 180 seg em um raio de 300 m. Filtro de viagens curtas: < 500m.
# Lissner e Huber (2021):
# 1. Viagens com menos de 30 seg são eliminadas;
# 2. Excluem pontos com velocidades maiores do que 90 km/h - dizem que valor pode
# variar de acordo com a fonte dos dados (tratamento em outliers extremos)
# 3. Distância entre pontos é Harversine, calculada a partir do latlong
# 4. Se há pontos com acurácia abaixo de 50m, ou seja, se há pontos com erro
# potencial maior do que o diâmetro de 50m em volta da posição original, os pontos
# GPS são excluídos (para lidar com refração ou multicaminho)
# Em Newson e Krumm (2009), o valor de amostragem (sampling) de 1 ponto a cada
# 90 segundos é quando há um salto de degradação no map matching da rota
tempo_max_quebra <- 90
# Rotas com frequência de sinal de 1 ponto a cada 30 seg possuíam erro de 0,01%
# (Newson e Krumm, 2009), mas inspeções manuais nos dados mostraram que a
# amostragem média deveria estar abaixo de 12 segundos (~200m)
interv_med_ptos  <- 12
df_trips = yellow_sp
library('nortest')
# Estrutura de pastas
pasta_dados        <- "../../yellow_dados"
pasta_base1         <- sprintf("%s/05_testes_viagens_20181111", pasta_dados)
open_file1 <- sprintf('%s/viagens_processadas_todas.csv', pasta_base1)
resultados1 <- read_delim(open_file1, delim = ';', col_types = 'cciidddddiddiiiiiiicc')
pasta_base2         <- sprintf("%s/05_testes_viagens_20181112-20181117", pasta_dados)
open_file2 <- sprintf('%s/viagens_processadas_todas.csv', pasta_base2)
resultados2 <- read_delim(open_file2, delim = ';', col_types = 'cciidddddiddiiiiiiicc')
resultados <- rbind(resultados1, resultados2)
rm(resultados1, resultados2, open_file1, open_file2)
head(resultados)
resultados %>%
select('tempo', 'dist', 'veloc', 'semaforos', 'elev_pos', 'elev_neg') %>%
summary()
# Scatterplots
plot(resultados$dist, resultados$veloc, cex = 0.25, xlim = c(0, 5000), ylim = c(0, 30))
plot(resultados$tempo, resultados$veloc, cex = 0.25, ylim = c(0, 40))
h_breaks <- ceiling(nrow(resultados)/10)
hist(resultados$veloc, breaks = h_breaks, xlim = c(0, 30))
# Boxplot
boxplot(resultados$veloc,
ylab = 'Velocidade', # Título do eixo x
cex.axis = 1.25,
cex.lab = 1.25, # Tamanho do título do eixo x
pch = 20) # Ver as bolinhas em formato 20 (pequenas e preenchidas)
resultados %>%
select(veloc) %>%
filter(veloc < 40) %>%
boxplot(
ylab = 'Velocidade', # Título do eixo x
cex.axis = 1.25,
cex.lab = 1.25, # Tamanho do título do eixo x
pch = 20) # Ver as bolinhas em formato 20 (pequenas e preenchidas)
resultados %>%
select(veloc) %>%
filter(veloc < 30) %>%
boxplot(
ylab = 'Velocidade', # Título do eixo x
cex.axis = 1.25,
cex.lab = 1.25, # Tamanho do título do eixo x
pch = 20) # Ver as bolinhas em formato 20 (pequenas e preenchidas)
resultados %>%
select(veloc) %>%
filter(veloc < 20) %>%
boxplot(
ylab = 'Velocidade', # Título do eixo x
cex.axis = 1.25,
cex.lab = 1.25, # Tamanho do título do eixo x
pch = 20) # Ver as bolinhas em formato 20 (pequenas e preenchidas)
resultados %>%
select('tempo', 'dist', 'veloc', 'semaforos', 'elev_pos', 'elev_neg') %>%
summary()
10*3.6
sel_trip <- '167857
# Isolar viagem de acordo com o seu trip_id
viagem <- df_trips %>% filter(trip_id == {{sel_trip}})
viagem %>% st_as_sf(coords = c("lon", "lat"), crs = 4326) %>% mapview(cex = 3, zcol = 'timestamps', at = seq(min(.$timestamps), max(.$timestamps), 200))
viagem %>% st_as_sf(coords = c("lon", "lat"), crs = 4326) %>% mapview(cex = 3, zcol = 'timestamps', at = seq(min(.$timestamps), max(.$timestamps), 200))
viagem <- df_trips %>% filter(trip_id == {{sel_trip}})
sel_trip <- '247325'
# Isolar viagem de acordo com o seu trip_id
viagem <- df_trips %>% filter(trip_id == {{sel_trip}})
viagem %>% st_as_sf(coords = c("lon", "lat"), crs = 4326) %>% mapview(cex = 3, zcol = 'timestamps', at = seq(min(.$timestamps), max(.$timestamps), 200))
viagem %>% select(lat, lon)
viagem %>% select(lat, lon) %>% mutate(lat = ac.character(lat), lon = as.character(lon))
viagem %>% select(lat, lon) %>% mutate(lat = as.character(lat), lon = as.character(lon))
viagem %>% select(lat, lon) %>% mutate(lat = as.character(lat), lon = as.character(lon)) %>% slice(40:60)
viagem %>% select(lat, lon) %>% mutate(lat = as.character(lat), lon = as.character(lon)) %>% slice(41:60)
sel_trip <- '282280'
# Isolar viagem de acordo com o seu trip_id
viagem <- df_trips %>% filter(trip_id == {{sel_trip}})
viagem %>% select(lat, lon) %>% mutate(lat = as.character(lat), lon = as.character(lon)) %>% slice(41:60)
# Retirar pontos que possuem as mesmas coordenadas latlong - este passo precisa
# ser feito antes do cálculo de tempo de tempo entre um ponto GPS e outro
viagem <- retirar_pontos_sobrepostos(viagem)
viagem %>% select(lat, lon) %>% mutate(lat = as.character(lat), lon = as.character(lon)) %>% slice(41:60)
viagem %>% st_as_sf(coords = c("lon", "lat"), crs = 4326) %>% mapview(cex = 3, zcol = 'timestamps', at = seq(min(.$timestamps), max(.$timestamps), 200))
resultados %>%
select('tempo', 'dist', 'veloc', 'semaforos', 'elev_pos', 'elev_neg') %>%
summary()
# Faz o map matching e realiza os cálculos referentes a rotas completas
# carregar bibliotecas
source('fun/setup.R')
source('fun/st_dbscan.R')
source('fun/funcoes_rotas.R')
source('fun/valhalla_map_matching.R')
# Estrutura de pastas
pasta_dados        <- "../../yellow_dados"
pasta_viagens_sp   <- sprintf("%s/01_viagens_em_sp", pasta_dados)
pasta_osm_sp       <- sprintf("%s/02_osm_simplificado_sp", pasta_dados)
pasta_elevacao     <- sprintf("%s/03_curva_elevacao_sp", pasta_dados)
pasta_semaforos    <- sprintf("%s/04_semaforos_sp", pasta_dados)
# pasta_base   <- sprintf("%s/05_testes_20_viagens_clusters", pasta_dados)
# pasta_base         <- sprintf("%s/05_testes_200_viagens_clusters", pasta_dados)
pasta_base         <- sprintf("%s/05_testes_viagens_20181112-20181117", pasta_dados)
pasta_viagens_gpkg <- sprintf("%s/viagens_processadas_gpkg", pasta_base)
pasta_viagens_pngs <- sprintf("%s/viagens_processadas_pngs", pasta_base)
pasta_viagens_csv1 <- sprintf("%s/viagens_processadas_csv1", pasta_base)
pasta_viagens_csv2 <- sprintf("%s/viagens_processadas_csv2", pasta_base)
dir.create(pasta_viagens_gpkg, recursive = TRUE, showWarnings = FALSE)
dir.create(pasta_viagens_pngs, recursive = TRUE, showWarnings = FALSE)
dir.create(pasta_viagens_csv1, recursive = TRUE, showWarnings = FALSE)
dir.create(pasta_viagens_csv2, recursive = TRUE, showWarnings = FALSE)
# Criar arquivo de log com header simples
log_base_name <- 'viagens_processadas_log'
log_file <- sprintf('%s/%s.csv', pasta_base, log_base_name)
# Se arquivo não existe, criar um header em um novo arquivo
if (!log_file %in% list.files(pasta_base, pattern = '^viagens_processadas_log.csv', full.names = TRUE)) {
log_head <- 'trip_id;id_trecho;proc_status'
write(log_head, file = log_file, append = FALSE)
# Se arquivo já existe, criar uma cópia de segurança - novos resultados serão
# adicionados ao arquivo
} else {
# Criar cópia do arquivo .pbf na nova pasta
ts <- Sys.time() %>% str_replace(' -03$', '') %>% str_replace(' ', '_') %>% str_replace_all('[-:]', '')
file.copy(log_file, sprintf('%s/%s_BKP_%s.csv', pasta_base, log_base_name, ts))
}
# ----------------------------------------------------------
# Abrir dados de apoio para os cálculos nas rotas
# ----------------------------------------------------------
# Abrir listagem de vias com infraestrutura cicloviária
vias_ciclo <- sprintf('%s/listagem_vias_infra_cicloviaria.csv', pasta_osm_sp)
vias_ciclo <- read_delim(vias_ciclo, delim = ';', col_types = cols(.default = "c"))
vias_ciclo <- vias_ciclo %>% select(osm_id, osm_cycletype = tipo_2018)
# Abrir listagem de vias em áreas com alguma restrição - parques, principalmente
vias_restritas <- sprintf('%s/listagem_vias_em_areas_restritas.csv', pasta_osm_sp)
vias_restritas <- read_delim(vias_restritas, delim = ';', col_types = cols(.default = "c"))
# # Abrir shape com linhas mestra e intermediária de elevação do Geosampa
# pontos_elevacao <- sprintf('%s/geosampa_pontos_de_elevacao_no_viario.gpkg', pasta_elevacao)
# pontos_elevacao <- read_sf(pontos_elevacao)
# Abrir shape com viário do OpenStreetMap com valoz Z incluído, vindo do MDT de SP
pontos_elevacao <- sprintf('%s/viario_osm_com_elevacao_mdt_sem_z.gpkg', pasta_elevacao)
pontos_elevacao <- read_sf(pontos_elevacao)
# Renomear coluna de elevação para 'ISOVALOR'
pontos_elevacao <- pontos_elevacao %>% rename(ISOVALOR = elev_mdt)
# Abrir esquinas com semáforos - buffers de 25m a partir do shape da CET
semaforos <- sprintf('%s/semaforos_buffer25_sp_dissolved.gpkg', pasta_semaforos)
semaforos <- read_sf(semaforos)
# ----------------------------------------------------------
# Abrir base de viagens
# ----------------------------------------------------------
# # Abrir a base de viagens da Yellow em SP
# open_file <- sprintf('%s/sp_20_viagens_teste.rds', pasta_base)
# viagens <- read_rds(open_file) %>% select(-n_points)
# Abrir a base de viagens da Yellow em SP
open_file <- sprintf('%s/sp_viagens_yellow.rds', pasta_viagens_sp)
yellow_sp <- read_rds(open_file) %>% rename(lat = lats,
lon = longs)
# Definir tempo mínimo de viagem, em segundos.Considerando uma média de 1 ponto
# a cada 5 segundos, temos: 18 pontos - 90 segundos - cerca de 300 metros a 12km/h.
# Com isso, rotas curtas são:
# 1. Com tempo menor do que 30s;
# 2. Com distância menor do que 300m;
# 3. Com quantidade mínima de 18 pontos
tempo_min_viagem <- 90
dist_min_viagem  <- 300
qtd_min_pontos   <- 18
# van de Coevering et al. (2014) consideraram como paradas quando ciclistas
# ficam mais de 180 seg em um raio de 300 m. Filtro de viagens curtas: < 500m.
# Lissner e Huber (2021):
# 1. Viagens com menos de 30 seg são eliminadas;
# 2. Excluem pontos com velocidades maiores do que 90 km/h - dizem que valor pode
# variar de acordo com a fonte dos dados (tratamento em outliers extremos)
# 3. Distância entre pontos é Harversine, calculada a partir do latlong
# 4. Se há pontos com acurácia abaixo de 50m, ou seja, se há pontos com erro
# potencial maior do que o diâmetro de 50m em volta da posição original, os pontos
# GPS são excluídos (para lidar com refração ou multicaminho)
# Em Newson e Krumm (2009), o valor de amostragem (sampling) de 1 ponto a cada
# 90 segundos é quando há um salto de degradação no map matching da rota
tempo_max_quebra <- 90
# Rotas com frequência de sinal de 1 ponto a cada 30 seg possuíam erro de 0,01%
# (Newson e Krumm, 2009), mas inspeções manuais nos dados mostraram que a
# amostragem média deveria estar abaixo de 12 segundos (~200m)
interv_med_ptos  <- 12
sel_trip <- '180975'; df_trips = yellow_sp # rota curta Av. Pedroso de Morais rumo ao metrô F. Lima
message(sprintf('Começando viagem id: %s', sel_trip))
# Status temporário do processamento da viagem
cp_a <- 0; cp_b <- cp_c <- cp_d <- cp_e <- '0'
# Isolar viagem de acordo com o seu trip_id
viagem <- df_trips %>% filter(trip_id == {{sel_trip}})
tam_vg <- nrow(viagem)
tam_vg
viagem
# viagem %>% st_as_sf(coords = c("lon", "lat"), crs = 4326) %>% mapview(cex = 3, zcol = 'timestamps', at = seq(min(.$timestamps), max(.$timestamps), 200))
viagem %>% st_as_sf(coords = c("lon", "lat"), crs = 4326) %>% mapview()
# Retirar pontos que possuem as mesmas coordenadas latlong - este passo precisa
# ser feito antes do cálculo de tempo de tempo entre um ponto GPS e outro
viagem <- retirar_pontos_sobrepostos(viagem)
# Se houve alteração, atualizar código de processamento da viagem
if (nrow(viagem) < tam_vg) { cp_b <- '1'; tam_vg <- nrow(viagem) }
# Reconhecer e retirar paradas com o st_dbscan() - valores de eps1, ep2 e minpts
# seguem o artigo de Lissner e Huber (2021), que por sua vez se basearam em
# van de Coevering et al (2014). Conversão da distância em graus de latitude/
# longitude em metros estimados com base em:
# https://www.usna.edu/Users/oceano/pguth/md_help/html/approx_equivalents.htm
clusters <- st_dbscan(x    = viagem$lon,
y    = viagem$lat,
time = viagem$timestamps,
# EPS1: 0.0001 = ~11 m; 0.0001352 = ~15 m; cálculo: eps1 = 0.0001*dist_m/11.1
eps1 = 0.0001352,
eps2 = 180,
# MINPTS: Em 1 ponto a cada 5 seg, 18 equivale a ~90 seg, para
# considerar eventuais paradas em semáforos
minpts = 18,
dry  = TRUE) %>%
as.data.frame()
# Filtrar somente pontos que pertencem ao cluster zero (ou seja, não são paradas)
viagem <- viagem %>% cbind(clusters) %>% filter(cluster == 0) %>% select(-cluster)
# viagem %>% st_as_sf(coords = c('lon', 'lat'), crs = 4326) %>% mapview(cex = 3)
rm(clusters)
# Se houve alteração e ainda há pontos, atualizar código de processamento da
# viagem e continuar
if (nrow(viagem) < tam_vg & nrow(viagem) > 0) {
cp_c <- '1'; tam_vg <- nrow(viagem)
# Se viagem era trecho estacionário e todos os pontos foram retirados,
# parar processamento e registrar código no log
} else if (nrow(viagem) == 0) {
# Atualizar código de processamento
cp_c <- '2'; cp_a2 <- sprintf('%02d', cp_a)
cod_proc <- sprintf('%s%s%sXXXXXXX', cp_a2, cp_b, cp_c)
# Registrar processamento da viagem no log
write(sprintf('%s;%s;%s', sel_trip, cp_a2, cod_proc), file = log_file, append = TRUE)
# Abortar processamento desta viagem
return(NULL)
}
# Remover outliers extremos de forma iterativa, até que não haja nenhum
result_outliers <- retirar_outliers_extremos_iterativo(viagem, max_iteracoes = 10)
# Registrar quantidade de iterações e atualizar dataframe da viagem
qtd_iteracoes <- result_outliers[[1]]
viagem <- result_outliers[[2]]
qtd_iteracoes
# Se houve alteração, atualizar código de processamento da viagem
if (nrow(viagem) < tam_vg) { cp_d <- '1'; tam_vg <- nrow(viagem) }
# viagem %>% st_as_sf(coords = c("lon", "lat"), crs = 4326) %>% mapview(cex = 3, zcol = 'timestamps', at = seq(min(.$timestamps), max(.$timestamps), 200))
viagem %>% st_as_sf(coords = c("lon", "lat"), crs = 4326) %>% mapview()
viagem
# Se houve alteração, atualizar código de processamento da viagem
if (nrow(viagem) < tam_vg) { cp_d <- '1'; tam_vg <- nrow(viagem) }
# Registrar quantidade de quebras detectadas na viagem
quebras_de_sinal <- detectar_quebras_em_viagens(viagem, max_break_time = tempo_max_quebra)
quebras_de_sinal
# Se a primeira linha do dataframe de viagem for uma quebra, retirá-la tanto
# do dataframe de viagem quanto do dataframe de quebras_de_sinal
if (1 %in% quebras_de_sinal$index) {
viagem <- viagem %>% slice(-1)
quebras_de_sinal <- quebras_de_sinal %>% slice(-1)
}
# Registrar quantidade de quebras de sinal
qtd_quebras <- nrow(quebras_de_sinal)
qtd_quebras
# Atualizar código de processamento da viagem e finalizar código
cp_e <- '0'; cp_a2 <- sprintf('%02d', cp_a)
cp_viagem <- sprintf('%s%s%s%s%s', cp_a2, cp_b, cp_c, cp_d, cp_e)
# Viagem possui duração, quantidade de pontos e frequência de sinal mínimas?
tempo_viagem <- get_elapsed_time(viagem)
tempo_viagem
cp_trecho <- validar_trecho(viagem, tempo_viagem, tempo_min_viagem, qtd_min_pontos, 'time_s')
cp_trecho
# Faz o trace_route() da rota. Este processo é o que resulta na distância mais
# próxima à calculada entre os pontos no QGIS e
trace_route_results <- trace_route_valhalla_main(trecho, sel_trip, active_mode)
trecho <- viagem
# Faz o trace_route() da rota. Este processo é o que resulta na distância mais
# próxima à calculada entre os pontos no QGIS e
trace_route_results <- trace_route_valhalla_main(trecho, sel_trip, active_mode)
trace_route_results
dist_rota  <- trace_route_results[[1]]
shape_rota <- trace_route_results[[2]]
dist_rota
mapview(shape_rota)
!is.na(dist_rota) & dist_rota >= dist_min_viagem
# Traçar rota com trace_attributes, pegar resposta e transformar em lista
r_at <- trace_attributes_valhalla(trecho, active_mode = 'pedestrian') # bicycle, pedestrian
r_at
http_status(r_at)$message == 'Success: (200) OK'
# Pegar a resposta do POST e usar str_c() - string collapse para transformar
# os vetores em uma única string, que por sua vez será transformada em um
# dataframe - estes elementos estarão facilmente acessíveis a partir dai
# https://www.qiushiyan.dev/post/json-column-r/
response_text_at <-
# Ignorar aviso 'argument is not an atomic vector; coercing'
suppressWarnings(str_c(r_at, collapse = ", ")) %>%
str_c("[", ., "]") %>%
fromJSON() %>%
as.data.frame()
response_text_at
# Pegar dados OSM: edges.way_id é o id que pode ser encontrado no OSM e seria
# o equivalende a um id do logradouro; edges.id é um id específico daquele
# edge e que, aparentemente, depende do versão do mapa que se está usando
trip_edges <- attributes_edges(response_text_at)
trip_edges
# Pegar dados dos pontos resultantes do map matching
trip_points <- attributes_matched_points(response_text_at)
# Associar matched_points com os dados dos edges
trip_points <-
trip_points %>%
left_join(trip_edges, by = c("matched_points.edge_index" = "edges.edge_index")) %>%
# Transformar way_id em character para left_joins futuros
mutate(edges.way_id = as.character(edges.way_id))
trip_points
# Se sim, associar as duas bases de dados
trecho <- trecho %>% cbind(trip_points)
trecho
# Limpar pontos que não conseguiram ser associados a um edge no map matching
trecho <- clean_matched_points(trecho, n_trip_edges = nrow(trip_edges))
# Marcar map matching como bem sucedido e retornar trecho com dados
cp_j <- '0'
trecho
cp_i <- '0';
cp_j == '0'
# ----------------------------------------------------------
# Inserir dados de elevação
# ----------------------------------------------------------
# Inserir dados de elevação - Geosampa
trecho <- get_elevation(trecho, pontos_elevacao)
trecho
# Calcular variações positivas e negativas de elevação com base no geosampa
elev_var     <- trecho %>% select(isovalor_var)
elev_geo_pos <- elev_var %>% filter(isovalor_var > 0) %>% sum()
elev_geo_neg <- elev_var %>% filter(isovalor_var < 0) %>% sum()
# ----------------------------------------------------------
# Inserir dados de infracicloviária e áreas restritas
# ----------------------------------------------------------
# Juntar dados relativos a vias com infraestrutura cicloviária
trecho <- trecho %>% left_join(vias_ciclo, by = c('edges.way_id' = 'osm_id'))
# Juntar dados se trecho está dentro de áreas restritas, tais como parques
trecho <- trecho %>% mutate(area_restrita =
case_when(!edges.way_id %in% vias_restritas$osm_id ~ FALSE,
TRUE ~ TRUE))
# ----------------------------------------------------------
# Quantidade de semátofos
# ----------------------------------------------------------
# Obter a quantidade de cruzamentos com semáforos ao longo da rota
qtd_semaforos <- semaforos %>% filter(st_intersects(shape_rota, semaforos, sparse = FALSE))
qtd_semaforos <- nrow(qtd_semaforos)
trip_df <- trecho
trecho
# Selecionar colunas de interesse
# trip_df <- trecho
calculos_edges <- trip_df %>% select(edges.way_id, edges.id, osm_cycletype, area_restrita, edges.length)
calculos_edges
calculos_edges %>%
# Vamos puxar os dados de edges.way_id e edges.length da linha de baixo
# para novas colunas
mutate(next_way_id  = shift(edges.way_id, type = 'lead'),
next_edge_id = shift(edges.id, type = 'lead'),
next_dist    = shift(edges.length, type = 'lead'))
boo <-
calculos_edges %>%
add_column(index_col = 1:nrow(.), .before = 'edges.way_id') %>%
# Vamos puxar os dados de edges.way_id e edges.length da linha de baixo
# para novas colunas
mutate(next_way_id  = shift(edges.way_id, type = 'lead'),
next_edge_id = shift(edges.id, type = 'lead'),
next_dist    = shift(edges.length, type = 'lead'))
boo
lala <-
calculos_edges %>%
add_column(index_col = 1:nrow(.), .before = 'edges.way_id') %>%
# Vamos puxar os dados de edges.way_id e edges.length da linha de baixo
# para novas colunas
mutate(next_way_id  = shift(edges.way_id, type = 'lead'),
next_edge_id = shift(edges.id, type = 'lead'),
next_dist    = shift(edges.length, type = 'lead')) %>%
filter(edges.way_id != next_way_id | edges.id != next_edge_id | next_dist != edges.length)
lala
sum(boo$edges.length)
sum(lala$edges.length)+78
39+78
calculos_edges %>%
add_column(index_col = 1:nrow(.), .before = 'edges.way_id') %>%
# Vamos puxar os dados de edges.way_id e edges.length da linha de baixo
# para novas colunas
mutate(next_way_id  = shift(edges.way_id, type = 'lead'),
next_edge_id = shift(edges.id, type = 'lead'),
next_dist    = shift(edges.length, type = 'lead')) %>%
distinct(edges.way_id, next_way_id, edges.id, next_edge_id, next_dist, edges.length, .keep_all = TRUE)
calculos_edges %>% tail(1)
# Para calcular as distâncias, temos que pegar os edges.way_id na ordem em que
# estão, com suas respectivas extensões (um mesmo id pode ter uma extensão
# diferente na linha seguinte) e somar os valores. Não podemos usar o distinct()
# aqui, se não perderemos trajetos que foram e voltaram passando por trechos iguais
calculos_edges <-
calculos_edges %>%
# Vamos puxar os dados de edges.way_id e edges.length da linha de baixo
# para novas colunas
mutate(next_way_id  = shift(edges.way_id, type = 'lead'),
next_edge_id = shift(edges.id, type = 'lead'),
next_dist    = shift(edges.length, type = 'lead'))
calculos_edges
# Guardar última linha, que será retirada no filtro a seguir
calculos_edges_tail <- calculos_edges %>% tail(1)
calculos_edges_tail
# O filtro aqui é: se a linha de baixo tiver um id diferente da atual ou
# tiver uma extensão diferente da atual, manter essa linha - isso faz com
# que linhas que se repetem (ex. foram usadas na ida e na volta) continuem
# no dataframe para a soma das extensões
calculos_edges <-
calculos_edges %>%
filter(edges.way_id != next_way_id | edges.id != next_edge_id | next_dist != edges.length) %>%
# Adicionar última linha, que havia sido descartada pelo filtro
rbind(calculos_edges_tail)
calculos_edges
# Calcular extensão total dos edges (sem repetição dos edges)
extensao_edges <- sum(calculos_edges$edges.length)
extensao_edges
shape_rota
viagem
map_matching_results
# Fazer map matching e registrar resultados
map_matching_results <- run_map_matching(viagem, sel_trip, tempo_viagem,
dist_min_viagem, active_mode,
pontos_elevacao, vias_ciclo,
vias_restritas, semaforos)
# Finalizar código de processamento, com resultado do map matching
cp_mm <- map_matching_results[[1]]
cod_proc <- sprintf('%s%s%s', cp_viagem, cp_trecho, cp_mm)
# Registrar shape da rota
viagem <- map_matching_results[[2]]
shape_rota <- map_matching_results[[3]]
viagem
741.649-740.106
trecho
