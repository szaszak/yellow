sentido_desloc %>%
# Deslocamentos no mesmo sentido do desenho da linha mantêm o sinal, senão
# o sinal é invertido
mutate(elev_grad_rev = case_when(linha_sent == 'des_linha' ~ elev_grad_sent_linha,
linha_sent == 'opo_linha' ~ elev_grad_sent_linha * -1),
# Agora que temos certeza sobre o sentido da linha e o gradiente,
# atualizar a classificação na coluna elev_sent. Trechos sem
# classificação vão ficar como NA
elev_sent = case_when(elev_grad_rev < 0 ~ 'descida',
elev_grad_rev > 0 ~ 'subida')) %>%
# Selecionar colunas de interesse, mantendo o dado sobre se a viagem está ou
# não no sentido da via (para detectar contramão)
select(cluster, linha_sent, elev_sent, elev_grad_rev)
# Agregar gradiente de declividade com sinal corrigido ao dataframe principal
resultados <-
resultados %>%
left_join(sentido_desloc, by = 'cluster')
# resultados %>% st_as_sf(coords = c('matched_points.lon', 'matched_points.lat'), crs = 4326) %>% mapview(zcol = 'elev_grad_rev')
}
# -----------------------------------------------------------------------------
# Calcular medianas de velocidades
# -----------------------------------------------------------------------------
# Insere no dataframe as colunas as medianas de velocidades para 3 e 5 pontos
calcular_medianas_velocidades <- function(resultados, speed_col) {
# speed_col <- 'speed_kph'
# Criar colunas de velocidades, para cálculo das medianas - cada coluna seguinte
# começa na linha de velocidade anterior da coluna atual
median_speeds <-
resultados %>%
select(s1 = {{speed_col}}) %>%
mutate(s2 = shift(s1, type = 'lead'),
s3 = shift(s2, type = 'lead'),
s4 = shift(s3, type = 'lead'),
s5 = shift(s3, type = 'lead'))
# Calcular medianas, tendo como base as 3 ou 5 colunas de velocidades
# https://stackoverflow.com/questions/54366592/r-how-to-take-median-of-rows-in-dataframe
median_speeds$ms3 <- apply(median_speeds[1:3], 1, median, na.rm = TRUE)
median_speeds$ms5 <- apply(median_speeds[1:5], 1, median, na.rm = TRUE)
# Agrupar resultados ao dataframe original
resultados <- resultados %>% mutate(speed_m3_kph = median_speeds$ms3,
speed_m5_kph = median_speeds$ms5)
}
# -----------------------------------------------------------------------------
# Agregar dados para modelo
# -----------------------------------------------------------------------------
# Gerar dataframe final com resultados agregados para serem udados no modelo
agregar_resultados <- function(resultados) {
# Gerar um datafrane
resultados <-
resultados %>%
group_by(trip_id, edges.way_id, qgis_id, cluster, edges.length, linha_sent, elev_sent) %>%
summarise(n_pontos     = first(n_pontos),
ts_inicio    = min(timestamps),
tempo_trecho = max(timestamps) - min(timestamps),
qgisid_ext_m = first(length_m),
vel_med_gps  = mean(speed_kph),
vel_med_m3   = mean(speed_m3_kph),
vel_med_m5   = mean(speed_m5_kph),
# curv_h       = first(curv_h),
# qtd_lotes    = first(lotes),
# class_via    = first(class_via),
# infra_ciclo  = first(infra_ciclo_2018),
# via_restr    = first(via_restr),
elev_grad_rev = first(elev_grad_rev)
) %>%
mutate(speed_kph = edges.length / tempo_trecho * 3.6, .after = 'qgisid_ext_m') %>%
arrange(cluster) %>%
ungroup()
# # Agregar dados de data (conversão do timestamp), hora e dia da semana
# resultados <-
#   resultados %>%
#   # Converter a coluna de timestamps para dia-mes-ano-hora
#   add_column(dh_inicio = as.POSIXlt(.$ts_inicio, origin = '1970-01-01'),
#              .after = 'ts_inicio') %>%
#   # Inserir colunas de dia da semana e hora
#   mutate(dia_semana = weekdays(dh_inicio, abbreviate = TRUE),
#          fx_hora    = format(dh_inicio, "%H"),
#          .after = 'dh_inicio')
#
#
# # Retirar arcos do viário (qgis_id) com quantidade de pontos menor do que 2
# resultados <- resultados %>% filter(n_pontos >= 2) %>% select(-cluster)
}
# -----------------------------------------------------------------------------
# Abrir todos resultados do map matching - base com pontos por trecho de viário
# -----------------------------------------------------------------------------
agrupar_para_modelos <- function(open_file) {
# this_name <- '000215_00.csv'
# this_name <- '027463_02.csv'
# this_file <- arqs_a_processar %>% add_column(seq_order = 1:nrow(.)) %>% filter(csv_name == this_name) %>% select(seq_order) %>% pull()
# open_file <- arqs_a_processar$csv_file[this_file]
# open_file <- arqs_a_processar$csv_file[1]
# filter(edges.way_id == '255818925')
# Resgatar nome do arquivo para usar depois como referência
file_id <- lapply(strsplit(open_file, split = '/'), tail, 1)
file_id <- str_split(file_id, '\\.')[[1]][1]
print(file_id)
# Ler arquivo resultante do map matching
resultados <- read_delim(open_file,
delim = ';',
col_types = 'cidddddddicddccciii',
col_select = c(trip_id,
timestamps,
# lat,
# lon,
# time_s,
# dist_m,
speed_kph,
edges.way_id,
# edges.id,
edges.length,
matched_points.lat,
matched_points.lon
))
# Atualizar o trip_id para incluir o identificador de trecho (_00, _01, etc)
resultados <-
resultados %>%
mutate(trip_id = file_id) %>%
add_column(seq_order = 1:nrow(.), .after = 'trip_id')
# Associar qgis_id ao trecho do viário e incluir os dados de atributo do viário
resultados <- associar_atrib_viario(resultados, pontos_viario, atrib_viario)
# Avaliar trajeto e consertar sinal de deciclidades
resultados <- consertar_sinal_declividade(resultados)
# Calcular medianas de velocidades
resultados <- calcular_medianas_velocidades(resultados, speed_kph)
# Agregar resultados para exportar para modelo
resultados <- agregar_resultados(resultados)
# Na rara ocasião em que pontos no nada não puderam ser associados de um
# osm_id a um qgis_id (função associar_atrib_viario()), a rota passa a ser
# arriscada - checar se isso aconteceu
qgis_id_vazios <- resultados %>% filter(is.na(qgis_id)) %>% nrow()
# Se houve problemas na associação, descartar rota e salvar dataframe vazio -
# os arquivos resultantes terão só o header e 159 bytes
if (qgis_id_vazios > 0) { resultados <- resultados %>% slice(0) }
# Salvar .csv
out_file <- sprintf('%s/%s_agrupado.csv', pasta_trechos_proc, file_id)
write_delim(resultados, out_file, delim = ';')
}
# -----------------------------------------------------------------------------
# Estrutura de pastas e arquivos
# -----------------------------------------------------------------------------
# Dados a atualizar de acordo com o mês a rodar
ano_mes <- '201901'
# Estrutura de pastas
pasta_dados        <- "../../yellow_dados"
pasta_atrib_viario <- sprintf('%s/04_atributos_viario', pasta_dados)
pasta_map_matching <- sprintf("%s/05_map_matching", pasta_dados)
pasta_mes_mapmatch <- sprintf("%s/%s", pasta_map_matching, ano_mes)
pasta_modelos      <- sprintf('%s/06_bases_para_modelo', pasta_dados)
pasta_trechos_proc <- sprintf("%s/A_trechos_processados/%s", pasta_modelos, ano_mes)
dir.create(pasta_trechos_proc, recursive = TRUE, showWarnings = FALSE)
# Abrir pontos de viário para associação entre osm_id (edges.way_id) e qgis_id
pontos_viario <- sprintf('%s/viario_osmid_qgisid_pontos_2m_draped_selecionados.gpkg', pasta_map_matching)
pontos_viario <- read_sf(pontos_viario)
# pontos_viario %>% filter(osm_id == '255818925') %>% mapview()
# Selecionar somente pontos do viário que serão usados neste batch
sel_osm_id <- sprintf('%s/%s_osmids_selecionados.csv', pasta_map_matching, ano_mes)
sel_osm_id <- read_delim(sel_osm_id, delim = ';', col_types = 'c')
pontos_viario <- pontos_viario %>% filter(osm_id %in% sel_osm_id$edges.way_id)
rm(sel_osm_id)
# Abrir arquivo com os atributos de viário agregados
atrib_viario <- sprintf('%s/00_listagem_viario_com_todos_atributos.csv', pasta_atrib_viario)
atrib_viario <- read_delim(atrib_viario, delim = ';', col_types = 'ccdddididdiddccccici')
# Deixar somente colunas de interesse para esta etapa - lembrando que aqui a
# coluna de elevação se refere ao sentido da linha traçada no shapefile do OSM
atrib_viario <- atrib_viario %>% select('osm_id', 'qgis_id', 'length_m', 'elev_grad_sent_linha')
# -----------------------------------------------------------------------------
# Isolar ids de viagens a serem processadas com base nos shapes de dist_total
# -----------------------------------------------------------------------------
# Abrir arquivo de resultados agregados (rota completa)
open_file <- sprintf('%s/%s_map_matching_rotas_completas.csv', pasta_mes_mapmatch, ano_mes)
res_agreg <- read_delim(open_file, delim = ';', col_types = 'cciiiddddTT')
# head(res_agreg)
# names(res_agreg)
# hist(res_agreg$veloc_vg_kph, breaks = 1280, xlim = c(0, 30))
# summary(res_agreg$veloc_vg_kph)
# Aplicar filtros - trechos com velocidade média mínima e máxima
res_agreg <-
res_agreg %>%
filter(veloc_vg_kph > 4 & veloc_vg_kph <= 30) %>%
# filter(prop_centr_100 < 33) %>%
filter(prop_centr_100 < 50) %>%
select(trip_id, cod_proc, tempo_total, dist_total, veloc_vg_kph)
# hist(res_agreg$veloc_vg_kph, breaks = 1280, xlim = c(0, 30))
# summary(res_agreg$veloc_vg_kph)
# Construir base de ids a serem processados
ids_a_processar <-
res_agreg %>%
mutate(cod_proc = substr(cod_proc, 1, 2),
csv_name = str_c(trip_id, '_', cod_proc, '.csv', sep = '')) %>%
select(csv_name)
# Limpar ambiente
rm(open_file, res_agreg)
# head(ids_a_processar)
# -----------------------------------------------------------------------------
# Listar arquivos resultantes do map matching (base com pontos) a serem processados
# -----------------------------------------------------------------------------
# Puxar todos os nomes de arquivos dos .csv resultantes, com path completo
pasta_csv_bruto  <- sprintf('%s/viagens_processadas_csv', pasta_mes_mapmatch)
arqs_a_processar <- list.files(pasta_csv_bruto, pattern = '*\\.csv', full.names = TRUE)
arqs_a_processar <- data.frame(csv_file = arqs_a_processar)
# Criar coluna com o nome do arquivo sem path e filtrar somente os que passaram
# pelo filtro da etapa anterior, de velocidades médias mínimas e máximas
arqs_a_processar <-
arqs_a_processar %>%
mutate(csv_name = lapply(strsplit(csv_file, split = '/'), tail, 1)) %>%
filter(csv_name %in% ids_a_processar$csv_name)
# Limpar ambiente
rm(pasta_csv_bruto,  ids_a_processar)
# head(arqs_a_processar)
# -----------------------------------------------------------------------------
# Processar todos os resultados do map matching e preparar base para modelo
# -----------------------------------------------------------------------------
# Atualizar arquivos a serem processados, removendo os que já foram
arqs_processados <- list.files(pasta_trechos_proc, pattern = '*\\.csv', full.names = FALSE)
arqs_processados <- arqs_processados %>% str_replace("_agrupado", "")
arqs_a_processar <- arqs_a_processar %>% filter(csv_name %nin% arqs_processados)
nrow(arqs_a_processar)
arqs_a_processar %>% head()
this_name <- '045007_00.csv'
this_file <- arqs_a_processar %>% add_column(seq_order = 1:nrow(.)) %>% filter(csv_name == this_name) %>% select(seq_order) %>% pull()
open_file <- arqs_a_processar$csv_file[this_file]
# Resgatar nome do arquivo para usar depois como referência
file_id <- lapply(strsplit(open_file, split = '/'), tail, 1)
file_id <- str_split(file_id, '\\.')[[1]][1]
print(file_id)
# Ler arquivo resultante do map matching
resultados <- read_delim(open_file,
delim = ';',
col_types = 'cidddddddicddccciii',
col_select = c(trip_id,
timestamps,
# lat,
# lon,
# time_s,
# dist_m,
speed_kph,
edges.way_id,
# edges.id,
edges.length,
matched_points.lat,
matched_points.lon
))
resultados
# Atualizar o trip_id para incluir o identificador de trecho (_00, _01, etc)
resultados <-
resultados %>%
mutate(trip_id = file_id) %>%
add_column(seq_order = 1:nrow(.), .after = 'trip_id')
resultados
# Associar qgis_id ao trecho do viário e incluir os dados de atributo do viário
resultados <- associar_atrib_viario(resultados, pontos_viario, atrib_viario)
# Ler arquivo resultante do map matching
resultados <- read_delim(open_file,
delim = ';',
col_types = 'cidddddddicddccciii',
col_select = c(trip_id,
timestamps,
# lat,
# lon,
# time_s,
# dist_m,
speed_kph,
edges.way_id,
# edges.id,
edges.length,
matched_points.lat,
matched_points.lon
))
# Atualizar o trip_id para incluir o identificador de trecho (_00, _01, etc)
resultados <-
resultados %>%
mutate(trip_id = file_id) %>%
add_column(seq_order = 1:nrow(.), .after = 'trip_id')
# Da base de resultados do map matching, selecionar os osm_ids únicos
sel_osm_ids <- resultados %>% distinct(edges.way_id)
# Da base de centróides do viário, isolar somente os trechos que possuem os
# osm_ids existentes nesta viagem - isso ajuda o processamento seguinte, do
# st_nearest_feature(), a rodar mais rápido
viarios_sel <-
pontos_viario %>%
filter(osm_id %in% sel_osm_ids$edges.way_id)
# Criar shape dos pontos associados ao viário - para isso, vamos usar os dados
# de latlong resultantes do map matching em vez dos originais
matched_points <-
resultados %>%
select(seq_order, edges.way_id, matched_points.lat, matched_points.lon) %>%
st_as_sf(coords = c('matched_points.lon', 'matched_points.lat'), crs = 4326)
id <- sel_osm_ids$edges.way_id[1]
id
# Filtrar somente linhas de resultados e altimetrias com o mesmo osm_id
tmp_resultados  <- matched_points %>% filter(edges.way_id == id)
tmp_pontos_viario <- viarios_sel %>% filter(osm_id == id)
nrow(tmp_pontos_viario) != 0
# Puxar os dados do ponto de altimetria mais próximo (do mesmo osm_id)
tmp_out <-
tmp_pontos_viario %>%
slice(st_nearest_feature(tmp_resultados, tmp_pontos_viario)) %>%
st_drop_geometry() %>%
select(qgis_id, distance, elev_mdt) %>%
# Adicionar a coluna de sq_order, que vai permitir reordenar o dataframe
add_column(seq_order = tmp_resultados$seq_order)
# Para cada osm_id existente na rota, vamos fazer uma associação de nearest
# feature com o centróide do víário - o importante neste passo é que só sejam
# associados os objetos que tenham o mesmo osm_id, por isso está sendo feito
# neste momento com um loop. Talvez haja uma forma mais elegante de fazer isso
tmp_df <- data.frame()
for (id in sel_osm_ids$edges.way_id) {
# print(id)
# id <- sel_osm_ids$edges.way_id[1]
# id <- '933975898'
# Filtrar somente linhas de resultados e altimetrias com o mesmo osm_id
tmp_resultados  <- matched_points %>% filter(edges.way_id == id)
tmp_pontos_viario <- viarios_sel %>% filter(osm_id == id)
# Os pontos resultantes do map matching sempre devem ser associados com os
# pontos selecionados do mapa OSM a cada 2m:
if (nrow(tmp_pontos_viario) != 0) {
# Puxar os dados do ponto de altimetria mais próximo (do mesmo osm_id)
tmp_out <-
tmp_pontos_viario %>%
slice(st_nearest_feature(tmp_resultados, tmp_pontos_viario)) %>%
st_drop_geometry() %>%
select(qgis_id, distance, elev_mdt) %>%
# Adicionar a coluna de sq_order, que vai permitir reordenar o dataframe
add_column(seq_order = tmp_resultados$seq_order)
} else {
# Na raríssima exceção em que essa associação não puder ser feita, criar
# um placeholder com qgis_id e elev_mdt iguais a NA. Esse placeholder vai
# ter o mesmo tamanho esperado devido à coluna seq_order
tmp_out <- data.frame(qgis_id = NA,
elev_mdt = NA,
seq_order = tmp_resultados$seq_order)
}
# Resultado é um dataframe com as colunas qis_id e seq_order - a ordem de
# sequência é a mesma dos dataframe de resultados e matched_points
tmp_df <- tmp_df %>% rbind(tmp_out)
}
tmp_df
# carregar bibliotecas
source('fun/setup.R')
# Estrutura de pastas
pasta_dados        <- "../../yellow_dados"
pasta_atrib_viario <- sprintf('%s/04_atributos_viario', pasta_dados)
pasta_map_matching <- sprintf("%s/05_map_matching", pasta_dados)
pasta_modelos      <- sprintf('%s/06_bases_para_modelo', pasta_dados)
pasta_base_agrup   <- sprintf('%s/B_processados_agrupados', pasta_modelos)
pasta_base_modelo  <- sprintf('%s/C_base_para_modelo', pasta_modelos)
dir.create(pasta_base_modelo, recursive = TRUE, showWarnings = FALSE)
# Abrir arquivo com os atributos de viário agregados
atrib_viario <- sprintf('%s/00_listagem_viario_com_todos_atributos.csv', pasta_atrib_viario)
atrib_viario <- read_delim(atrib_viario, delim = ';', col_types = 'ccdddididdiddccccici')
head(atrib_viario)
# Abrir arquivos processados
base_modelo <- list.files(path = pasta_base_agrup,
pattern = '^\\d{6}_trechos_processados_todos.csv',
recursive = FALSE,
full.names = TRUE)
# arq_trechos_proc <- sprintf('%s/trechos_processados_todos.csv', pasta_base_agrup)
# base_modelo <- read_delim(arq_trechos_proc, delim = ';', col_types = 'cccicidddddddd')
base_modelo <-
lapply(X = base_modelo, FUN = read_delim, delim = ';', col_types = 'ccciicidddddddd') %>%
rbindlist(fill = TRUE)
# arq_trechos_proc <- sprintf('%s/trechos_processados_todos.csv', pasta_base_agrup)
# base_modelo <- read_delim(arq_trechos_proc, delim = ';', col_types = 'cccicidddddddd')
base_modelo <-
lapply(X = base_modelo, FUN = read_delim, delim = ';', col_types = 'ccciiccidddddddd') %>%
rbindlist(fill = TRUE)
# Abrir arquivos processados
base_modelo <- list.files(path = pasta_base_agrup,
pattern = '^\\d{6}_trechos_processados_todos.csv',
recursive = FALSE,
full.names = TRUE)
# arq_trechos_proc <- sprintf('%s/trechos_processados_todos.csv', pasta_base_agrup)
# base_modelo <- read_delim(arq_trechos_proc, delim = ';', col_types = 'cccicidddddddd')
base_modelo <-
lapply(X = base_modelo, FUN = read_delim, delim = ';', col_types = 'ccciiccidddddddd') %>%
rbindlist(fill = TRUE)
head(base_modelo)
# Arquivos com distâncias totais por trecho
ano_mes <- c('201811', '201812', '201901')
arqs_dist_tot <- c()
for (a_m in ano_mes) {
search_folder <- sprintf('%s/%s', pasta_map_matching, a_m)
result_files  <- list.files(search_folder,
pattern = '^\\d{6}_map_matching_rotas_completas.csv',
recursive = FALSE,
full.names = TRUE)
arqs_dist_tot <- c(arqs_dist_tot, result_files)
}
arqs_dist_tot
# Abrir arquivos, já selecionando somente colunas de interesse
ext_totais <-
lapply(X = arqs_dist_tot, FUN = read_delim, delim = ';', col_types = 'cciiiddddTT') %>%
rbindlist(fill = TRUE) %>%
select(trip_id, cod_proc, dist_total)
head(ext_totais)
# Limpar ambiente
rm(ano_mes, arqs_dist_tot, search_folder, result_files)
# Retirar alguns qgis_id que estão dando problema
qgis_id_problematicos <- c(
'037565' # Pista da Raia da USP
)
trip_id_problematicos <- c(
# '013918_12' # Túnel da 9 de Julho
)
base_modelo <- base_modelo %>% filter(qgis_id %nin% qgis_id_problematicos & trip_id %nin% trip_id_problematicos)
base_modelo
# Retirar alguns qgis_id que estão dando problema - valores precisam ser re-checados
# caso o mapa base OSM do processamento tenha sido alterado
qgis_id_problematicos <- c(
'035959' # Pista da Raia da USP
)
trip_id_problematicos <- c(
# '013918_12' # Túnel da 9 de Julho
)
base_modelo <- base_modelo %>% filter(qgis_id %nin% qgis_id_problematicos & trip_id %nin% trip_id_problematicos)
# Quantos trechos possuem pelo menos três viagens por sentido da via?
viagens_por_trecho <- base_modelo %>% group_by(qgis_id, elev_sent) %>% tally()
viagens_por_trecho
viagens_validas <- viagens_por_trecho %>% filter(n > 2)
head(viagens_validas)
# Retirar da base do modelo os trechos com menos de uma viagem por sentido
base_modelo <- base_modelo %>% filter(qgis_id %in% viagens_validas$qgis_id)
rm(viagens_por_trecho, viagens_validas)
# Retirar da base os trechos em que o sentido do deslocamento não foi identificado
base_modelo <- base_modelo %>% filter(!is.na(elev_sent))
head(base_modelo)
# Simplificar dataframe de extensões totais
ext_totais <-
ext_totais %>%
# Recriar coluna trip_id, considerando os dois primeiros caractares de cod_proc
mutate(cod_proc   = substr(cod_proc, 1, 2),
trecho_id  = str_c(trip_id, '_', cod_proc, sep = '')) %>%
select(-cod_proc, vg_id = trip_id, dist_total_trecho_m = dist_total) %>%
# Retirar duplicatas
distinct()
# Juntar extensões totais à base principal - teremos, temporariamente, uma coluna
# chamada 'vg_id' que se refere ao id original da viagem
base_modelo <- base_modelo %>% left_join(ext_totais, by = c('trip_id' = 'trecho_id'))
head(base_modelo)
# Quantas viagens serão consideradas no modelo final? - 164.466
n_viagens <- base_modelo %>% select(vg_id) %>% distinct() %>% nrow()
# Quantos trechos dessas viagens serão consideradas no modelo final? - 182.773
n_trechos <- base_modelo %>% select(trip_id) %>% distinct() %>% nrow()
# Retirar coluna temporária de vg_id da base geral
base_modelo <- base_modelo %>% select(-vg_id)
names(atrib_viario)
# Deixar somente colunas de interesse para esta etapa
atrib_viario <- atrib_viario %>% select(qgis_id, curv_h, lotes_tot, lotes_15m, lotes_30m,
dens_lotes_100m, dens_lotes_100m_15m, dens_lotes_100m_30m,
class_via, infra_ciclo, via_restr,
osm_oneway, osm_lanes, osm_surface, osm_maxspeed)
# Associar os atributos de viário restantes à base
base_modelo <- base_modelo %>% left_join(atrib_viario, by = 'qgis_id')
head(base_modelo)
# Quantos trechos de via (qgis_id) estão sem info de sentido?
base_modelo %>% group_by(qgis_id, osm_oneway) %>% tally()
# Quantos trechos de via (qgis_id) estão sem info de sentido?
base_modelo %>% group_by(qgis_id, osm_oneway) %>% filter(is.na(osm_oneway)) %>% tally()
# Quantos trechos de via (qgis_id) estão sem info de sentido?
base_modelo %>% filter(is.na(osm_oneway)) %>% select(qgis_id) %>% distinct()
# Quantos trechos de via (qgis_id) estão sem info de sentido?
base_modelo %>% filter(is.na(osm_oneway))
# Quantos qgis_id temos?
base_modelo %>% select(qgis_id) %>% distinct() %>% pull()
# Quantos qgis_id temos?
base_modelo %>% select(qgis_id) %>% distinct() %>% nrow()
# Quantos trechos de via (qgis_id) estão sem info de sentido? # 0
base_modelo %>% filter(is.na(osm_lanes)) %>% select(qgis_id) %>% distinct()
# Quantos trechos de via (qgis_id) estão sem info de sentido? # 0
base_modelo %>% filter(is.na(osm_lanes)) %>% select(qgis_id) %>% distinct() %>% pull()
# Quantos trechos de via (qgis_id) estão sem info de sentido? # 0
base_modelo %>% filter(is.na(osm_lanes)) %>% select(qgis_id) %>% distinct() %>% nrow()
12816/26987*100
# Quantos trechos de via (qgis_id) estão sem info de superfície? # 12816/26987*100 = 47,5%
base_modelo %>% filter(is.na(osm_surface)) %>% select(qgis_id) %>% distinct() %>% nrow()
6661/26987*100
# Quantos trechos de via (qgis_id) estão sem info de velocidade máxima? # 6661/26987*100 = 24,7%
base_modelo %>% filter(is.na(osm_maxspeed)) %>% select(qgis_id) %>% distinct() %>% nrow()
16633/26987*100
# Feriados 2018 e 2019
feriados <- c(as.Date('2018-10-12'), # Nossa Senhora Aparecida
as.Date('2018-11-02'), # Finados (sexta)
as.Date('2018-11-15'), # Procl. República (quinta)
as.Date('2018-12-24'), # Natal (terça)
as.Date('2019-01-01'), # Ano novo (terça)
as.Date('2019-02-13'), # Carnaval (terça)
as.Date('2019-03-30'), # Sexta feira santa (sábado)
as.Date('2019-04-21')  # Tiradentes (domingo)
)
# Agregar dados de data (conversão do timestamp), hora e dia da semana
base_modelo <-
base_modelo %>%
# Converter a coluna de timestamps para dia-mes-ano-hora
add_column(dh_inicio = as.POSIXlt(.$ts_inicio, origin = '1970-01-01'),
.after = 'ts_inicio') %>%
# Inserir colunas de dia da semana e hora
mutate(dia_semana = weekdays(dh_inicio, abbreviate = TRUE),
fx_hora    = format(dh_inicio, "%H"),
.after = 'dh_inicio') %>%
# Converter coluna de hora para numeric
mutate(fx_hora = as.numeric(fx_hora))
# Atualizar coluna de dia da semana para marcar feriados
base_modelo <-
base_modelo %>%
mutate(dia_semana  = ifelse(as.Date(dh_inicio) %in% feriados, 'fer', dia_semana))
# Descartar coluna de dh_inicio
base_modelo <- base_modelo %>% select(-dh_inicio)
head(base_modelo)
# Exportar resultados
out_file <- sprintf('%s/yellow_base_para_modelo.csv', pasta_base_modelo)
write_delim(base_modelo, out_file, delim = ';')
